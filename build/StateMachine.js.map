{"version":3,"sources":["StateMachine.js","StateMachine.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","StateMachine","StateMachine_1","StateMachine.isUndefined","StateMachine.State","this","StateMachine.State.constructor","_this","StateMachine.State._makeEventHandler","StateMachine.State.on","_len","arguments","length","StateMachine.State.emit","StateMachine.StateMachine","StateMachine.StateMachine.constructor","StateMachine.StateMachine.init","StateMachine.StateMachine.state","StateMachine.StateMachine.emit","StateMachine.StateMachine.go"],"mappings":"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","file":"StateMachine.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar StateMachine;\n(function (StateMachine_1) {\n    function isUndefined(x) {\n        return typeof x === \"undefined\";\n    }\n\n    var State = (function () {\n        /**\n         * A single state\n         *\n         * @param sm - state machine\n         * @param name - state name\n         */\n\n        function State(sm, name) {\n            _classCallCheck(this, State);\n\n            this._sm = sm;\n            this.name = name;\n            this._events = {};\n            this._enter = [];\n            this._exit = [];\n        }\n\n        _createClass(State, {\n            _makeEventHandler: {\n                /**\n                 * Convert an event handler parameter to a function\n                 *\n                 * @param x Handler parameter\n                 * @return Event handler\n                 */\n\n                value: function _makeEventHandler(x) {\n                    var _this = this;\n\n                    if (typeof x === \"function\") {\n                        return x;\n                    }\n                    if (typeof x === \"string\") {\n                        return function () {\n                            return _this._sm.go(x);\n                        };\n                    }\n                    if (typeof x === \"undefined\") {\n                        return function () {\n                            return undefined;\n                        };\n                    }\n                    throw new Error(\"invalid event handler\");\n                }\n            },\n            on: {\n                /**\n                 * Register a state event and add the event method\n                 * to the state machine instance\n                 *\n                 * Note:\n                 *\n                 *  `enter` and `exit` are special events.\n                 *  event methods do not get defined for them.\n                 *  they are executed when the state machine is\n                 *  entering or exiting that state.\n                 *\n                 * @param event Event name\n                 * @param handler Event callback function or state name\n                 * @return State\n                 */\n\n                value: function on(event, handler) {\n                    var events = this._events,\n                        sm = this._sm,\n                        fn = this._makeEventHandler(handler);\n                    switch (event) {\n                        case \"enter\":\n                            this._enter.push(fn);\n                            break;\n                        case \"exit\":\n                            this._exit.push(fn);\n                            break;\n                        default:\n                            if (!events.hasOwnProperty(event)) {\n                                events[event] = [];\n                            }\n                            events[event].push(fn);\n                    }\n                    return this;\n                }\n            },\n            emit: {\n                /**\n                 * Emit an event\n                 *\n                 * @param event Event name\n                 * @param args Arguments to pass to event handler\n                 */\n\n                value: function emit(event) {\n                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                        args[_key - 1] = arguments[_key];\n                    }\n\n                    var sm = this._sm,\n                        verbose = sm.options.verbose,\n                        name = sm.options.name,\n                        logEx = sm.options.logExceptions,\n                        state = this,\n                        events;\n                    if (state === null) {\n                        throw new Error(\"the state machine has not been initialized\");\n                    }\n                    events = state._events;\n                    if (!events.hasOwnProperty(event)) {\n                        throw new Error(event + \" event not defined for \" + state.name + \" state\");\n                    }\n                    if (verbose) {\n                        console.log(name + \": \" + state.name + \".\" + event);\n                    }\n                    if (logEx) {\n                        try {\n                            events[event].forEach(function (fn) {\n                                return fn.apply(sm, args);\n                            });\n                        } catch (e) {\n                            console.log(name + \": \" + state.name + \" ! \" + e.message);\n                            throw e;\n                        }\n                    } else {\n                        events[event].forEach(function (fn) {\n                            return fn.apply(sm, args);\n                        });\n                    }\n                }\n            }\n        });\n\n        return State;\n    })();\n\n    StateMachine_1.State = State;\n\n    var StateMachine = (function () {\n        /**\n         * @param options Options\n         */\n\n        function StateMachine(options) {\n            _classCallCheck(this, StateMachine);\n\n            this._states = {};\n            this.current = null;\n            if (isUndefined(options)) {\n                options = {};\n            }\n            if (isUndefined(options.verbose)) {\n                options.verbose = false;\n            }\n            if (isUndefined(options.name)) {\n                options.name = \"StateMachine\";\n            }\n            if (isUndefined(options.logExceptions)) {\n                options.logExceptions = false;\n            }\n            this.options = options;\n        }\n\n        _createClass(StateMachine, {\n            init: {\n                /**\n                 * Initializes the state machine to an initial state.\n                 * trying to invoke event methods before initializing\n                 * will result in an `Error` being thrown\n                 *\n                 * @param name Initial state name\n                 * @return State machine\n                 */\n\n                value: function init(name) {\n                    var states = this._states;\n                    if (isUndefined(states[name])) {\n                        throw new Error(name + \" state is not defined\");\n                    }\n                    this.current = states[name];\n                }\n            },\n            state: {\n                /**\n                 * Creates or gets existing State\n                 *\n                 * @param Name - state name\n                 * @return State specified by name\n                 */\n\n                value: function state(name) {\n                    var states = this._states;\n                    if (!states.hasOwnProperty(name)) {\n                        states[name] = new State(this, name);\n                    }\n                    return states[name];\n                }\n            },\n            emit: {\n                /**\n                 * Emit an event\n                 *\n                 * @param event Event name\n                 * @param args Arguments to pass to event handler\n                 */\n\n                value: function emit(event) {\n                    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                        args[_key - 1] = arguments[_key];\n                    }\n\n                    var state = this.current;\n                    if (state === null) {\n                        throw new Error(\"the state machine has not been initialized\");\n                    }\n                    state.emit.apply(state, arguments);\n                }\n            },\n            go: {\n                /**\n                 * Go to another state\n                 *\n                 * @param name State to transition to\n                 */\n\n                value: function go(name) {\n                    var _this = this;\n\n                    var state = this._states[name],\n                        current = this.current,\n                        execute = function (fn) {\n                        return fn.call(_this);\n                    };\n                    if (isUndefined(state)) {\n                        throw new Error(name + \" state does not exist\");\n                    }\n                    if (current.name !== name) {\n                        if (this.options.verbose) {\n                            console.log(this.options.name + \": \" + current.name + \" -> \" + name);\n                        }\n                        current._exit.forEach(execute);\n                        this.current = state;\n                        state._enter.forEach(execute);\n                    }\n                }\n            }\n        });\n\n        return StateMachine;\n    })();\n\n    StateMachine_1.StateMachine = StateMachine;\n})(StateMachine || (StateMachine = {}));","module StateMachine {\n\n  function isUndefined(x) {\n    return typeof x === \"undefined\";\n  }\n\n  export interface EventHandler {\n    (...any): any;\n  }\n\n  export class State {\n\n    name:   string;\n    _enter: Array<EventHandler>;\n    _exit:  Array<EventHandler>;\n\n    private _sm:     StateMachine;\n    private _events: any;\n\n    /**\n     * A single state\n     *\n     * @param sm - state machine\n     * @param name - state name\n     */\n    constructor(sm: StateMachine, name: string) {\n      this._sm     = sm;\n      this.name    = name;\n      this._events = {};\n      this._enter  = [];\n      this._exit   = [];\n    }\n\n    /**\n     * Convert an event handler parameter to a function\n     *\n     * @param x Handler parameter\n     * @return Event handler\n     */\n    private _makeEventHandler(x?: EventHandler|string): EventHandler {\n      if (typeof x === \"function\") {\n        return x;\n      }\n      if (typeof x === \"string\") {\n        return () => this._sm.go(x);\n      }\n      if (typeof x === \"undefined\") {\n        return () => undefined;\n      }\n      throw new Error(\"invalid event handler\");\n    }\n\n    /**\n     * Register a state event and add the event method\n     * to the state machine instance\n     *\n     * Note:\n     *\n     *  `enter` and `exit` are special events.\n     *  event methods do not get defined for them.\n     *  they are executed when the state machine is\n     *  entering or exiting that state.\n     *\n     * @param event Event name\n     * @param handler Event callback function or state name\n     * @return State \n     */\n    on(event: string, handler?: EventHandler|string): State {\n      var events = this._events,\n          sm     = this._sm,\n          fn     = this._makeEventHandler(handler);\n      switch (event) {\n        case \"enter\":\n          this._enter.push(fn);\n          break;\n        case \"exit\":\n          this._exit.push(fn);\n          break;\n        default:\n          if (!events.hasOwnProperty(event)) {\n            events[event] = [];\n          }\n          events[event].push(fn);\n      }\n      return this;\n    }\n\n    /**\n     * Emit an event\n     *\n     * @param event Event name\n     * @param args Arguments to pass to event handler\n     */\n    emit(event: string, ...args: Array<any>): void {\n      var sm      = this._sm,\n          verbose = sm.options.verbose,\n          name    = sm.options.name,\n          logEx   = sm.options.logExceptions,\n          state   = this,\n          events;\n\n      if (state === null) {\n        throw new Error(\"the state machine has not been initialized\");\n      }\n      events = state._events;\n      if (!events.hasOwnProperty(event)) {\n        throw new Error(\n          event + \" event not defined for \" + state.name + \" state\"\n        );\n      }\n      if (verbose) {\n        console.log(name + \": \" + state.name + \".\" + event);\n      }\n      if (logEx) {\n        try {\n          events[event].forEach(\n              (fn) => fn.apply(sm, args))\n        } catch (e) {\n          console.log(name + \": \" + state.name + \" ! \" + e.message);\n          throw e;\n        }\n      } else {\n        events[event].forEach(\n            (fn) => fn.apply(sm, args));\n      }\n    }\n\n  }\n\n  export interface Options {\n    name?:          string;\n    verbose?:       boolean;\n    logExceptions?: boolean;\n  }\n\n  export interface EventMethod {\n    (...any): any;\n  }\n\n  export class StateMachine {\n\n    private _states:  { [name: string]: State };\n\n    current: State;\n    options: Options;\n\n    /**\n     * @param options Options\n     */\n    constructor(options?: Options) {\n      this._states  = {};\n      this.current = null;\n\n      if (isUndefined(options)) {\n        options = {};\n      }\n      if (isUndefined(options.verbose)) {\n        options.verbose = false;\n      }\n      if (isUndefined(options.name)) {\n        options.name = \"StateMachine\";\n      }\n      if (isUndefined(options.logExceptions)) {\n        options.logExceptions = false;\n      }\n      this.options = options;\n    }\n\n    /**\n     * Initializes the state machine to an initial state.\n     * trying to invoke event methods before initializing\n     * will result in an `Error` being thrown\n     *\n     * @param name Initial state name\n     * @return State machine\n     */\n    init(name: string) {\n      var states = this._states;\n      if (isUndefined(states[name])) {\n        throw new Error(name + \" state is not defined\");\n      }\n      this.current = states[name];\n    }\n\n    /**\n     * Creates or gets existing State\n     *\n     * @param Name - state name\n     * @return State specified by name\n     */\n    state(name: string): State {\n      var states = this._states;\n      if (!states.hasOwnProperty(name)) {\n        states[name] = new State(this, name);\n      }\n      return states[name];\n    }\n\n    /**\n     * Emit an event\n     *\n     * @param event Event name\n     * @param args Arguments to pass to event handler\n     */\n    emit(event: string, ...args: Array<any>): void {\n      var state = this.current;\n      if (state === null) {\n        throw new Error(\"the state machine has not been initialized\");\n      }\n      state.emit.apply(state, arguments);\n    }\n\n    /**\n     * Go to another state\n     *\n     * @param name State to transition to\n     */\n    go(name: string): void {\n      var state   = this._states[name],\n          current = this.current,\n          execute = fn => fn.call(this);\n      if (isUndefined(state)) {\n        throw new Error(name + \" state does not exist\");\n      }\n      if (current.name !== name) {\n        if (this.options.verbose) {\n          console.log(this.options.name + \": \" + current.name + \" -> \" + name);\n        }\n        current._exit.forEach(execute);\n        this.current = state;\n        state._enter.forEach(execute);\n      }\n    }\n  }\n\n}\n"],"sourceRoot":"/source/"}