{"version":3,"sources":["EventEmitter.ts"],"names":["EventEmitterListenerGroup","emitter","this","_unbind","_emitter","prototype","addListener","name","callback","unbind","push","removeAllListeners","_i","_a","slice","length","EventEmitter","_eventEmitterChannels","_this","hasOwnProperty","removeListener","channels","channel","index","indexOf","splice","emitEvent","payload","listener","createListenerGroup"],"mappings":"AAGA,GAAAA,2BAAA,WAKE,QAAAA,GAAYC,GAFJC,KAAAC,WAGND,KAAKE,SAAWH,EAwBpB,MAfED,GAAAK,UAAAC,YAAA,SAAeC,EAASC,GACtB,GAAIC,GAASP,KAAKE,SAASE,YAAYC,EAAMC,EAC7CN,MAAKC,QAAQO,KAAKD,IAMpBT,EAAAK,UAAAM,mBAAA,WACE,IAAmB,GAAAC,GAAA,EAAAC,EAAAX,KAAKC,QAAQW,QAAbF,EAAAC,EAAAE,OAAAH,IAAoB,CAAlC,GAAIH,GAAMI,EAAAD,EACbH,KAEFP,KAAKC,YAGTH,KAEAgB,aAAA,WAAA,QAAAA,KAEUd,KAAAe,yBAuEV,MA/DED,GAAAX,UAAAC,YAAA,SAAeC,EAASC,GAAxB,GAAAU,GAAAhB,IAKE,OAJKA,MAAKe,sBAAsBE,eAAeZ,KAC7CL,KAAKe,sBAAsBV,OAE7BL,KAAKe,sBAAsBV,GAAaG,KAAKF,GACtC,WAAM,MAAAU,GAAKE,eAAeb,EAAMC,KASzCQ,EAAAX,UAAAe,eAAA,SAAeb,EAASC,GACtB,GAAIa,GAAWnB,KAAKe,qBACpB,IAAII,EAASF,eAAeZ,GAAc,CACxC,GAAIe,GAAUD,EAASd,GACnBgB,EAAQD,EAAQE,QAAQhB,EACxBe,MAAU,GACZD,EAAQG,OAAOF,EAAO,KAU5BP,EAAAX,UAAAM,mBAAA,SAAmBJ,GACG,mBAATA,GACTL,KAAKe,yBACIf,KAAKe,sBAAsBE,eAAeZ,UAC5CL,MAAKe,sBAAsBV,IAUtCS,EAAAX,UAAAqB,UAAA,SAAUnB,EAASoB,GACjB,GAAKzB,KAAKe,sBAAsBE,eAAeZ,GAI/C,IAAqB,GADjBe,GAAUpB,KAAKe,sBAAsBV,GACpBK,EAAA,EAAAC,EAAAS,EAAQR,QAARF,EAAAC,EAAAE,OAAAH,IAAe,CAA/B,GAAIgB,GAAQf,EAAAD,EACfgB,GAASD,KASbX,EAAAX,UAAAwB,oBAAA,WACE,MAAO,IAAI7B,2BAA0BE,OAGzCc","file":"EventEmitter.js","sourcesContent":["\ntype EventEmitterCallback<T> = (payload?: T) => any;\n\nclass EventEmitterListenerGroup<E> {\n\n  private _emitter: EventEmitter<E>;\n  private _unbind: Function[] = [];\n  \n  constructor(emitter: EventEmitter<E>) {\n    this._emitter = emitter;\n  }\n\n  /**\n   * Add an event listener\n   *\n   * @param name The event to subscribe to \n   * @param callback The callback function to invoke\n   */\n  addListener<T>(name: E, callback: EventEmitterCallback<T>): void {\n    let unbind = this._emitter.addListener(name, callback);\n    this._unbind.push(unbind);\n  }\n\n  /**\n   * Remove all event listeners in group\n   */\n  removeAllListeners(): void {\n    for (let unbind of this._unbind.slice()) {\n      unbind();\n    }\n    this._unbind = [];\n  }\n\n}\n\nclass EventEmitter<E> {\n\n  private _eventEmitterChannels: { [name: number]: EventEmitterCallback<any>[]; } = {};\n\n  /**\n   * Add an event listener\n   *\n   * @param name The event to subscribe to @param callback The callback function to invoke\n   * @return unbind function\n   */\n  addListener<T>(name: E, callback: EventEmitterCallback<T>): Function {\n    if (!this._eventEmitterChannels.hasOwnProperty(name as any)) {\n      this._eventEmitterChannels[name as any] = [];\n    }\n    this._eventEmitterChannels[name as any].push(callback);\n    return () => this.removeListener(name, callback);\n  }\n\n  /**\n   * Remove an event listener\n   *\n   * @param name The event to unsubscribe from\n   * @param callback The callback to unsubscribe\n   */\n  removeListener(name: E, callback: EventEmitterCallback<any>): void {\n    let channels = this._eventEmitterChannels;\n    if (channels.hasOwnProperty(name as any)) {\n      let channel = channels[name as any];\n      let index = channel.indexOf(callback);\n      if (index !== -1) {\n        channel.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all event listeners\n   *\n   * @param name Event to reset (defaults to all)\n   */\n  removeAllListeners(name?: E): void {\n    if (typeof name === 'undefined') {\n      this._eventEmitterChannels = {};\n    } else if (this._eventEmitterChannels.hasOwnProperty(name as any)) {\n      delete this._eventEmitterChannels[name as any];\n    }\n  }\n\n  /**\n   * Emit an event\n   *\n   * @param name The event type\n   * @param payload Optional data passed to listeners\n   */\n  emitEvent(name: E, payload?: any): void {\n    if (!this._eventEmitterChannels.hasOwnProperty(name as any)) {\n      return;\n    }\n    let channel = this._eventEmitterChannels[name as any];\n    for (let listener of channel.slice()) {\n      listener(payload);\n    }\n  }\n\n  /**\n   * Create a group of listeners that can be unbound all together\n   *\n   * @return a group of listeners\n   */\n  createListenerGroup(): EventEmitterListenerGroup<E> {\n    return new EventEmitterListenerGroup(this);\n  }\n\n}\n"]}