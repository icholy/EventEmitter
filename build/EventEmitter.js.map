{"version":3,"sources":["EventEmitter.js","EventEmitter.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","EventEmitterListenerGroup","this","EventEmitterListenerGroup.constructor","EventEmitterListenerGroup.addEventListener","EventEmitterListenerGroup.removeEventListeners","EventEmitter","EventEmitter.constructor","_this","EventEmitter.addEventListener","EventEmitter.removeEventListener","EventEmitter.removeEventListeners","EventEmitter.emitEvent","EventEmitter.createListenerGroup"],"mappings":"AAAA,YAEA,IAAIA,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,KAAOD,GAAO,CAAE,GAAIE,GAAOF,EAAMC,EAAMC,GAAKC,cAAe,EAAUD,EAAKE,QAAOF,EAAKG,UAAW,GAAQC,OAAOR,iBAAiBC,EAAQC,GAAU,MAAO,UAAUO,EAAaC,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBS,EAAYG,UAAWF,GAAiBC,GAAaX,EAAiBS,EAAaE,GAAqBF,MAEvaI,gBAAkB,SAAUC,EAAUL,GAAe,KAAMK,YAAoBL,IAAgB,KAAM,IAAIM,WAAU,sCCDvHC,0BAAA,WAKEA,QALFA,GAKcA,GDANH,gBAAgBI,KCLxBD,GAGUE,KAAAA,WAGNA,KAAKA,SAAWA,EDiChB,MA5BAnB,cCXJiB,GAeEA,kBDKUV,MCLMU,SAACA,EAASA,GACxBG,GAAIA,GAASA,KAAKA,SAASA,iBAAiBA,EAAMA,EAClDA,MAAKA,QAAQA,KAAKA,KAMpBH,sBDOUV,MCPUU,WAClBI,KAAKA,QAAQA,QAAQA,SAACA,GDQN,MCRiBA,OACjCA,KAAKA,eAzBTJ,KA8BAK,aAAA,WAAAA,QAAAA,KDcQR,gBAAgBI,KCdxBI,GAEUC,KAAAA,yBDsGN,MArFAvB,cCnBJsB,GAUEA,kBDkBUf,MClBMe,SAACA,EAASA,GDmBZ,GAAIE,GAAQN,ICbxBO,OALKA,MAAKA,sBAAsBA,eAAoBA,GAGlDA,KAAKA,sBAA2BA,GAAMA,KAAKA,GAF3CA,KAAKA,sBAA2BA,IAASA,GAIpCA,WDqBS,MCrBHA,GAAKA,oBAAoBA,EAAMA,MAS9CH,qBDwBUf,MCxBSe,SAACA,EAASA,GAC3BI,GAAIA,GAAWA,KAAKA,qBACpBA,IAAIA,EAASA,eAAoBA,GAAOA,CACtCA,GAAIA,GAAUA,EAAcA,GACxBA,EAAQA,EAAQA,QAAQA,EACdA,MAAVA,GACFA,EAAQA,OAAOA,EAAOA,MAU5BJ,sBD0BUf,MC1BUe,SAACA,GACCK,mBAATA,GACTA,KAAKA,yBACIA,KAAKA,sBAAsBA,eAAoBA,UACjDA,MAAKA,sBAA2BA,KAU3CL,WD4BUf,MC5BDe,SAACA,EAASA,GACbM,KAAKA,sBAAsBA,eAAoBA,IACjDA,KAAKA,sBAA2BA,GAAMA,QAAQA,SAACA,GAC7CA,EAASA,OAUfN,qBD8BUf,MC9BSe,WACjBO,MAAOA,IAAIA,2BAA0BA,UArEzCP","file":"EventEmitter.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar EventEmitterListenerGroup = (function () {\n    function EventEmitterListenerGroup(emitter) {\n        _classCallCheck(this, EventEmitterListenerGroup);\n\n        this._unbind = [];\n        this._emitter = emitter;\n    }\n\n    _createClass(EventEmitterListenerGroup, {\n        addEventListener: {\n            /**\n             * Add an event listener\n             *\n             * @param name The event to subscribe to\n             * @param callback The callback function to invoke\n             */\n\n            value: function addEventListener(name, callback) {\n                var unbind = this._emitter.addEventListener(name, callback);\n                this._unbind.push(unbind);\n            }\n        },\n        removeEventListeners: {\n            /**\n             * Remove all event listeners in group\n             */\n\n            value: function removeEventListeners() {\n                this._unbind.forEach(function (unbind) {\n                    return unbind();\n                });\n                this._unbind = [];\n            }\n        }\n    });\n\n    return EventEmitterListenerGroup;\n})();\n\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        _classCallCheck(this, EventEmitter);\n\n        this._eventEmitterChannels = {};\n    }\n\n    _createClass(EventEmitter, {\n        addEventListener: {\n            /**\n             * Add an event listener\n             *\n             * @param name The event to subscribe to @param callback The callback function to invoke\n             * @return unbind function\n             */\n\n            value: function addEventListener(name, callback) {\n                var _this = this;\n\n                if (!this._eventEmitterChannels.hasOwnProperty(name)) {\n                    this._eventEmitterChannels[name] = [callback];\n                } else {\n                    this._eventEmitterChannels[name].push(callback);\n                }\n                return function () {\n                    return _this.removeEventListener(name, callback);\n                };\n            }\n        },\n        removeEventListener: {\n            /**\n             * Remove an event listener\n             *\n             * @param name The event to unsubscribe from\n             * @param callback The callback to unsubscribe\n             */\n\n            value: function removeEventListener(name, callback) {\n                var channels = this._eventEmitterChannels;\n                if (channels.hasOwnProperty(name)) {\n                    var channel = channels[name];\n                    var index = channel.indexOf(callback);\n                    if (index !== -1) {\n                        channel.splice(index, 1);\n                    }\n                }\n            }\n        },\n        removeEventListeners: {\n            /**\n             * Remove all event listeners\n             *\n             * @param name Event to reset (defaults to all)\n             */\n\n            value: function removeEventListeners(name) {\n                if (typeof name === \"undefined\") {\n                    this._eventEmitterChannels = {};\n                } else if (this._eventEmitterChannels.hasOwnProperty(name)) {\n                    delete this._eventEmitterChannels[name];\n                }\n            }\n        },\n        emitEvent: {\n            /**\n             * Emit an event\n             *\n             * @param name The event type\n             * @param payload Optional data passed to listeners\n             */\n\n            value: function emitEvent(name, payload) {\n                if (this._eventEmitterChannels.hasOwnProperty(name)) {\n                    this._eventEmitterChannels[name].forEach(function (callback) {\n                        callback(payload);\n                    });\n                }\n            }\n        },\n        createListenerGroup: {\n            /**\n             * Create a group of listeners that can be unbound all together\n             *\n             * @return a group of listeners\n             */\n\n            value: function createListenerGroup() {\n                return new EventEmitterListenerGroup(this);\n            }\n        }\n    });\n\n    return EventEmitter;\n})();","\ntype EventEmitterCallback = (payload?: any) => any;\n\nclass EventEmitterListenerGroup<E> {\n\n  private _emitter: EventEmitter<E>;\n  private _unbind: Function[] = [];\n  \n  constructor(emitter: EventEmitter<E>) {\n    this._emitter = emitter;\n  }\n\n  /**\n   * Add an event listener\n   *\n   * @param name The event to subscribe to \n   * @param callback The callback function to invoke\n   */\n  addEventListener(name: E, callback: EventEmitterCallback): void {\n    let unbind = this._emitter.addEventListener(name, callback);\n    this._unbind.push(unbind);\n  }\n\n  /**\n   * Remove all event listeners in group\n   */\n  removeEventListeners(): void {\n    this._unbind.forEach((unbind) => unbind());\n    this._unbind = [];\n  }\n\n}\n\nclass EventEmitter<E> {\n\n  private _eventEmitterChannels: { [name:number]: EventEmitterCallback[]; } = {};\n\n  /**\n   * Add an event listener\n   *\n   * @param name The event to subscribe to @param callback The callback function to invoke\n   * @return unbind function\n   */\n  addEventListener(name: E, callback: EventEmitterCallback): (...any) => any {\n    if (!this._eventEmitterChannels.hasOwnProperty(<any>name)) {\n      this._eventEmitterChannels[<any>name] = [callback];\n    } else {\n      this._eventEmitterChannels[<any>name].push(callback);\n    }\n    return () => this.removeEventListener(name, callback);\n  }\n\n  /**\n   * Remove an event listener\n   *\n   * @param name The event to unsubscribe from\n   * @param callback The callback to unsubscribe\n   */\n  removeEventListener(name: E, callback: EventEmitterCallback): void {\n    let channels = this._eventEmitterChannels;\n    if (channels.hasOwnProperty(<any>name)) {\n      let channel = channels[<any>name];\n      let index = channel.indexOf(callback);\n      if (index !== -1) {\n        channel.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all event listeners\n   *\n   * @param name Event to reset (defaults to all)\n   */\n  removeEventListeners(name?: E): void {\n    if (typeof name === 'undefined') {\n      this._eventEmitterChannels = {};\n    } else if (this._eventEmitterChannels.hasOwnProperty(<any>name)) {\n      delete this._eventEmitterChannels[<any>name];\n    }\n  }\n\n  /**\n   * Emit an event\n   *\n   * @param name The event type\n   * @param payload Optional data passed to listeners\n   */\n  emitEvent(name: E, payload?: any): void {\n    if (this._eventEmitterChannels.hasOwnProperty(<any>name)) {\n      this._eventEmitterChannels[<any>name].forEach((callback) => {\n        callback(payload);\n      });\n    }\n  }\n\n  /**\n   * Create a group of listeners that can be unbound all together\n   *\n   * @return a group of listeners\n   */\n  createListenerGroup(): EventEmitterListenerGroup<E> {\n    return new EventEmitterListenerGroup(this);\n  }\n\n}\n"],"sourceRoot":"/source/"}