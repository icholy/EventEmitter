{"version":3,"sources":["EventEmitter.js","EventEmitter.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","EventEmitterGroup","this","EventEmitterGroup.constructor","EventEmitterGroup.on","EventEmitterGroup.off","EventEmitter","EventEmitter.constructor","_this","EventEmitter.on","EventEmitter.off","EventEmitter.reset","EventEmitter.emit","EventEmitter.group"],"mappings":"AAAA,YAEA,IAAIA,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,KAAOD,GAAO,CAAE,GAAIE,GAAOF,EAAMC,EAAMC,GAAKC,cAAe,EAAUD,EAAKE,QAAOF,EAAKG,UAAW,GAAQC,OAAOR,iBAAiBC,EAAQC,GAAU,MAAO,UAAUO,EAAaC,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBS,EAAYG,UAAWF,GAAiBC,GAAaX,EAAiBS,EAAaE,GAAqBF,MAEvaI,gBAAkB,SAAUC,EAAUL,GAAe,KAAMK,YAAoBL,IAAgB,KAAM,IAAIM,WAAU,sCCDvHC,kBAAA,WAKEA,QALFA,GAKcA,GDANH,gBAAgBI,KCLxBD,GAGUE,KAAAA,WAGNA,KAAKA,SAAWA,EDgChB,MA3BAnB,cCXJiB,GAeEA,IDKUV,MCLRU,SAACA,EAASA,GACVG,GAAIA,GAASA,KAAKA,SAASA,GAAGA,EAAMA,EACpCA,MAAKA,QAAQA,KAAKA,KAMpBH,KDOUV,MCPPU,WACDI,KAAKA,QAAQA,QAAQA,SAACA,GACpBA,UAzBNJ,KA+BAK,aAAA,WAAAA,QAAAA,KDYQR,gBAAgBI,KCZxBI,GAEUC,KAAAA,aDoGN,MArFAvB,cCjBJsB,GAUEA,IDgBUf,MChBRe,SAACA,EAASA,GDiBE,GAAIE,GAAQN,ICXxBO,OALKA,MAAKA,UAAUA,eAAoBA,GAGtCA,KAAKA,UAAeA,GAAMA,KAAKA,GAF/BA,KAAKA,UAAeA,IAASA,GAIxBA,WDmBS,MCnBHA,GAAKA,IAAIA,EAAMA,MAS9BH,KDsBUf,MCtBPe,SAACA,EAASA,GACXI,GAAIA,GAAWA,KAAKA,SACpBA,IAAIA,EAASA,eAAoBA,GAAOA,CACtCA,GAAIA,GAAUA,EAAcA,GACxBA,EAAQA,EAAQA,QAAQA,EACdA,MAAVA,GACFA,EAAQA,OAAOA,EAAOA,MAU5BJ,ODwBUf,MCxBLe,SAACA,GACgBK,mBAATA,GACTA,KAAKA,aACIA,KAAKA,UAAUA,eAAoBA,UACrCA,MAAKA,UAAeA,KAU/BL,MD0BUf,MC1BNe,SAACA,EAASA,GACRM,KAAKA,UAAUA,eAAoBA,IACrCA,KAAKA,UAAeA,GAAMA,QAAQA,SAACA,GACjCA,EAASA,OAUfN,OD4BUf,MC5BLe,WACHO,MAAOA,IAAIA,mBAAkBA,UArEjCP","file":"EventEmitter.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar EventEmitterGroup = (function () {\n    function EventEmitterGroup(emitter) {\n        _classCallCheck(this, EventEmitterGroup);\n\n        this._unbind = [];\n        this._emitter = emitter;\n    }\n\n    _createClass(EventEmitterGroup, {\n        on: {\n            /**\n             * Add an event listener\n             *\n             * @param name The event to subscribe to\n             * @param callback The callback function to invoke\n             */\n\n            value: function on(name, callback) {\n                var unbind = this._emitter.on(name, callback);\n                this._unbind.push(unbind);\n            }\n        },\n        off: {\n            /**\n             * Remove all event listeners in group\n             */\n\n            value: function off() {\n                this._unbind.forEach(function (unbind) {\n                    unbind();\n                });\n            }\n        }\n    });\n\n    return EventEmitterGroup;\n})();\n\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        _classCallCheck(this, EventEmitter);\n\n        this._channels = {};\n    }\n\n    _createClass(EventEmitter, {\n        on: {\n            /**\n             * Add an event listener\n             *\n             * @param name The event to subscribe to @param callback The callback function to invoke\n             * @return unbind function\n             */\n\n            value: function on(name, callback) {\n                var _this = this;\n\n                if (!this._channels.hasOwnProperty(name)) {\n                    this._channels[name] = [callback];\n                } else {\n                    this._channels[name].push(callback);\n                }\n                return function () {\n                    return _this.off(name, callback);\n                };\n            }\n        },\n        off: {\n            /**\n             * Remove an event listener\n             *\n             * @param name The event to unsubscribe from\n             * @param callback The callback to unsubscribe\n             */\n\n            value: function off(name, callback) {\n                var channels = this._channels;\n                if (channels.hasOwnProperty(name)) {\n                    var channel = channels[name];\n                    var index = channel.indexOf(callback);\n                    if (index !== -1) {\n                        channel.splice(index, 1);\n                    }\n                }\n            }\n        },\n        reset: {\n            /**\n             * Remove all event listeners\n             *\n             * @param name Event to reset (defaults to all)\n             */\n\n            value: function reset(name) {\n                if (typeof name === \"undefined\") {\n                    this._channels = {};\n                } else if (this._channels.hasOwnProperty(name)) {\n                    delete this._channels[name];\n                }\n            }\n        },\n        emit: {\n            /**\n             * Emit an event\n             *\n             * @param name The event type\n             * @param payload Optional data passed to listeners\n             */\n\n            value: function emit(name, payload) {\n                if (this._channels.hasOwnProperty(name)) {\n                    this._channels[name].forEach(function (callback) {\n                        callback(payload);\n                    });\n                }\n            }\n        },\n        group: {\n            /**\n             * Create a group of listeners that can be unbound all together\n             *\n             * @return a group of listeners\n             */\n\n            value: function group() {\n                return new EventEmitterGroup(this);\n            }\n        }\n    });\n\n    return EventEmitter;\n})();","\ntype EventEmitterCallback = (payload?: any) => any;\n\nclass EventEmitterGroup<E> {\n\n  private _emitter: EventEmitter<E>;\n  private _unbind: Function[] = [];\n  \n  constructor(emitter: EventEmitter<E>) {\n    this._emitter = emitter;\n  }\n\n  /**\n   * Add an event listener\n   *\n   * @param name The event to subscribe to \n   * @param callback The callback function to invoke\n   */\n  on(name: E, callback: EventEmitterCallback): void {\n    let unbind = this._emitter.on(name, callback);\n    this._unbind.push(unbind);\n  }\n\n  /**\n   * Remove all event listeners in group\n   */\n  off(): void {\n    this._unbind.forEach((unbind) => {\n      unbind();\n    });\n  }\n\n}\n\nclass EventEmitter<E> {\n\n  private _channels: { [name:number]: EventEmitterCallback[]; } = {};\n\n  /**\n   * Add an event listener\n   *\n   * @param name The event to subscribe to @param callback The callback function to invoke\n   * @return unbind function\n   */\n  on(name: E, callback: EventEmitterCallback): (...any) => any {\n    if (!this._channels.hasOwnProperty(<any>name)) {\n      this._channels[<any>name] = [callback];\n    } else {\n      this._channels[<any>name].push(callback);\n    }\n    return () => this.off(name, callback);\n  }\n\n  /**\n   * Remove an event listener\n   *\n   * @param name The event to unsubscribe from\n   * @param callback The callback to unsubscribe\n   */\n  off(name: E, callback: EventEmitterCallback): void {\n    let channels = this._channels;\n    if (channels.hasOwnProperty(<any>name)) {\n      let channel = channels[<any>name];\n      let index = channel.indexOf(callback);\n      if (index !== -1) {\n        channel.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all event listeners\n   *\n   * @param name Event to reset (defaults to all)\n   */\n  reset(name?: E): void {\n    if (typeof name === 'undefined') {\n      this._channels = {};\n    } else if (this._channels.hasOwnProperty(<any>name)) {\n      delete this._channels[<any>name];\n    }\n  }\n\n  /**\n   * Emit an event\n   *\n   * @param name The event type\n   * @param payload Optional data passed to listeners\n   */\n  emit(name: E, payload?: any): void {\n    if (this._channels.hasOwnProperty(<any>name)) {\n      this._channels[<any>name].forEach((callback) => {\n        callback(payload);\n      });\n    }\n  }\n\n  /**\n   * Create a group of listeners that can be unbound all together\n   *\n   * @return a group of listeners\n   */\n  group(): EventEmitterGroup<E> {\n    return new EventEmitterGroup(this);\n  }\n\n}\n"],"sourceRoot":"/source/"}