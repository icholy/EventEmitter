{"version":3,"sources":["EventEmitter.js","EventEmitter.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","EventEmitter","this","EventEmitter.constructor","_this","EventEmitter.on","EventEmitter.off","EventEmitter.reset","EventEmitter.emit"],"mappings":"AAAA,YAEA,IAAIA,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,KAAOD,GAAO,CAAE,GAAIE,GAAOF,EAAMC,EAAMC,GAAKC,cAAe,EAAUD,EAAKE,QAAOF,EAAKG,UAAW,GAAQC,OAAOR,iBAAiBC,EAAQC,GAAU,MAAO,UAAUO,EAAaC,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBS,EAAYG,UAAWF,GAAiBC,GAAaX,EAAiBS,EAAaE,GAAqBF,MAEvaI,gBAAkB,SAAUC,EAAUL,GAAe,KAAMK,YAAoBL,IAAgB,KAAM,IAAIM,WAAU,sCCDvHC,aAAA,WAAAA,QAAAA,KDKQH,gBAAgBI,KCLxBD,GAEUE,KAAAA,aDmFN,MA3EAnB,cCVJiB,GAWEA,IDSUV,MCTRU,SAACA,EAASA,GDUE,GAAIG,GAAQF,ICJxBG,OALKA,MAAKA,UAAUA,eAAoBA,GAGtCA,KAAKA,UAAeA,GAAMA,KAAKA,GAF/BA,KAAKA,UAAeA,IAASA,GAIxBA,WDYS,MCZHA,GAAKA,IAAIA,EAAMA,MAS9BJ,KDeUV,MCfPU,SAACA,EAASA,GACXK,GAAIA,GAAWA,KAAKA,SACpBA,IAAIA,EAASA,eAAoBA,GAAOA,CACtCA,GAAIA,GAAUA,EAAcA,GACxBA,EAAQA,EAAQA,QAAQA,EACdA,MAAVA,GACFA,EAAQA,OAAOA,EAAOA,MAU5BL,ODiBUV,MCjBLU,SAACA,GACgBM,mBAATA,GACTA,KAAKA,aACIA,KAAKA,UAAUA,eAAoBA,UACrCA,MAAKA,UAAeA,KAU/BN,MDmBUV,MCnBNU,SAACA,EAASA,GACRO,KAAKA,UAAUA,eAAoBA,IACrCA,KAAKA,UAAeA,GAAMA,QAAQA,SAACA,GACjCA,EAASA,SA3DjBP","file":"EventEmitter.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        _classCallCheck(this, EventEmitter);\n\n        this._channels = {};\n    }\n\n    _createClass(EventEmitter, {\n        on: {\n            /**\n             * Add an event listener\n             *\n             * @param name The event to subscribe to\n             * @param callback The callback function to invoke\n             * @return unbind function\n             */\n\n            value: function on(name, callback) {\n                var _this = this;\n\n                if (!this._channels.hasOwnProperty(name)) {\n                    this._channels[name] = [callback];\n                } else {\n                    this._channels[name].push(callback);\n                }\n                return function () {\n                    return _this.off(name, callback);\n                };\n            }\n        },\n        off: {\n            /**\n             * Remove an event listener\n             *\n             * @param name The event to unsubscribe from\n             * @param callback The callback to unsubscribe\n             */\n\n            value: function off(name, callback) {\n                var channels = this._channels;\n                if (channels.hasOwnProperty(name)) {\n                    var channel = channels[name];\n                    var index = channel.indexOf(callback);\n                    if (index !== -1) {\n                        channel.splice(index, 1);\n                    }\n                }\n            }\n        },\n        reset: {\n            /**\n             * Remove all event listeners\n             *\n             * @param name Event to reset (defaults to all)\n             */\n\n            value: function reset(name) {\n                if (typeof name === \"undefined\") {\n                    this._channels = {};\n                } else if (this._channels.hasOwnProperty(name)) {\n                    delete this._channels[name];\n                }\n            }\n        },\n        emit: {\n            /**\n             * Emit an event\n             *\n             * @param name The event type\n             * @param payload Optional data passed to listeners\n             */\n\n            value: function emit(name, payload) {\n                if (this._channels.hasOwnProperty(name)) {\n                    this._channels[name].forEach(function (callback) {\n                        callback(payload);\n                    });\n                }\n            }\n        }\n    });\n\n    return EventEmitter;\n})();","\ntype EventEmitterCallback = (payload?: any) => any;\n\nclass EventEmitter<E> {\n\n  private _channels: { [name:number]: EventEmitterCallback[]; } = {};\n\n  /**\n   * Add an event listener\n   *\n   * @param name The event to subscribe to\n   * @param callback The callback function to invoke\n   * @return unbind function\n   */\n  on(name: E, callback: EventEmitterCallback): (...any) => any {\n    if (!this._channels.hasOwnProperty(<any>name)) {\n      this._channels[<any>name] = [callback];\n    } else {\n      this._channels[<any>name].push(callback);\n    }\n    return () => this.off(name, callback);\n  }\n\n  /**\n   * Remove an event listener\n   *\n   * @param name The event to unsubscribe from\n   * @param callback The callback to unsubscribe\n   */\n  off(name: E, callback: EventEmitterCallback): void {\n    let channels = this._channels;\n    if (channels.hasOwnProperty(<any>name)) {\n      let channel = channels[<any>name];\n      let index = channel.indexOf(callback);\n      if (index !== -1) {\n        channel.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all event listeners\n   *\n   * @param name Event to reset (defaults to all)\n   */\n  reset(name?: E): void {\n    if (typeof name === 'undefined') {\n      this._channels = {};\n    } else if (this._channels.hasOwnProperty(<any>name)) {\n      delete this._channels[<any>name];\n    }\n  }\n\n  /**\n   * Emit an event\n   *\n   * @param name The event type\n   * @param payload Optional data passed to listeners\n   */\n  emit(name: E, payload?: any): void {\n    if (this._channels.hasOwnProperty(<any>name)) {\n      this._channels[<any>name].forEach((callback) => {\n        callback(payload);\n      });\n    }\n  }\n}\n"],"sourceRoot":"/source/"}