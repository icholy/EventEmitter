{"version":3,"sources":["EventEmitter.js","EventEmitter.ts"],"names":["_createClass","defineProperties","target","props","key","prop","configurable","value","writable","Object","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","EventEmitter","this","EventEmitter.constructor","_this","EventEmitter.on","EventEmitter.off","EventEmitter.emit"],"mappings":"AAAA,YAEA,IAAIA,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,KAAOD,GAAO,CAAE,GAAIE,GAAOF,EAAMC,EAAMC,GAAKC,cAAe,EAAUD,EAAKE,QAAOF,EAAKG,UAAW,GAAQC,OAAOR,iBAAiBC,EAAQC,GAAU,MAAO,UAAUO,EAAaC,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBS,EAAYG,UAAWF,GAAiBC,GAAaX,EAAiBS,EAAaE,GAAqBF,MAEvaI,gBAAkB,SAAUC,EAAUL,GAAe,KAAMK,YAAoBL,IAAgB,KAAM,IAAIM,WAAU,sCCDvHC,aAAA,WAAAA,QAAAA,KDKQH,gBAAgBI,KCLxBD,GAEUE,KAAAA,aD8CN,MAtCAnB,cCVJiB,GAIEA,IDQUV,MCRRU,SAACA,EAASA,GDSE,GAAIG,GAAQF,ICHxBG,OALKA,MAAKA,UAAUA,eAAoBA,GAGtCA,KAAKA,UAAeA,GAAMA,KAAKA,GAF/BA,KAAKA,UAAeA,IAASA,GAIxBA,WDWS,MCXHA,GAAKA,IAAIA,EAAMA,MAG9BJ,KDaUV,MCbPU,SAACA,EAASA,GACXK,GAAIA,GAAWA,KAAKA,SACpBA,IAAIA,EAASA,eAAoBA,GAAOA,CACtCA,GAAIA,GAAUA,EAAcA,GACxBA,EAAQA,EAAQA,QAAQA,EACdA,MAAVA,GACFA,EAAQA,OAAOA,EAAOA,MAK5BL,MDcUV,MCdNU,SAACA,EAASA,GACRM,KAAKA,UAAUA,eAAoBA,IACrCA,KAAKA,UAAeA,GAAMA,QAAQA,SAACA,GACjCA,EAASA,SA3BjBN","file":"EventEmitter.js","sourcesContent":["\"use strict\";\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\n\nvar EventEmitter = (function () {\n    function EventEmitter() {\n        _classCallCheck(this, EventEmitter);\n\n        this._channels = {};\n    }\n\n    _createClass(EventEmitter, {\n        on: {\n            value: function on(name, callback) {\n                var _this = this;\n\n                if (!this._channels.hasOwnProperty(name)) {\n                    this._channels[name] = [callback];\n                } else {\n                    this._channels[name].push(callback);\n                }\n                return function () {\n                    return _this.off(name, callback);\n                };\n            }\n        },\n        off: {\n            value: function off(name, callback) {\n                var channels = this._channels;\n                if (channels.hasOwnProperty(name)) {\n                    var channel = channels[name];\n                    var index = channel.indexOf(callback);\n                    if (index !== -1) {\n                        channel.splice(index, 1);\n                    }\n                }\n            }\n        },\n        emit: {\n            value: function emit(name, payload) {\n                if (this._channels.hasOwnProperty(name)) {\n                    this._channels[name].forEach(function (callback) {\n                        callback(payload);\n                    });\n                }\n            }\n        }\n    });\n\n    return EventEmitter;\n})();","\ntype EventEmitterCallback = (payload?: any) => any;\n\nclass EventEmitter<E> {\n\n  private _channels: { [name:number]: EventEmitterCallback[]; } = {};\n\n  on(name: E, callback: EventEmitterCallback): Function {\n    if (!this._channels.hasOwnProperty(<any>name)) {\n      this._channels[<any>name] = [callback];\n    } else {\n      this._channels[<any>name].push(callback);\n    }\n    return () => this.off(name, callback);\n  }\n\n  off(name: E, callback: EventEmitterCallback): void {\n    let channels = this._channels;\n    if (channels.hasOwnProperty(<any>name)) {\n      let channel = channels[<any>name];\n      let index = channel.indexOf(callback);\n      if (index !== -1) {\n        channel.splice(index, 1);\n      }\n    }\n  }\n\n  emit(name: E, payload?: any): void {\n    if (this._channels.hasOwnProperty(<any>name)) {\n      this._channels[<any>name].forEach((callback) => {\n        callback(payload);\n      });\n    }\n  }\n}\n"],"sourceRoot":"/source/"}